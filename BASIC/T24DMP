*-----------------------------------------------------------------------------
* <Rating>31</Rating>
*-----------------------------------------------------------------------------
    PROGRAM T24DMP
*-----------------------------------------------------------------------------
* Extracts T24 file contents with a perfect header and sample of records
*
* TODO: Extract user fields as well
* TODO: Limit sample size
*-----------------------------------------------------------------------------
    $INSERT I_COMMON
    $INSERT I_EQUATE
    $INSERT I_F.STANDARD.SELECTION
    $INSERT I_F.LOCAL.REF.TABLE
    $INSERT I_F.LOCAL.TABLE

    ret_msg = ''

    GOSUB parseArguments
    IF NOT(ret_msg) THEN

        GOSUB openFiles
        IF NOT(ret_msg) THEN

            header = '@ID'
            local_ref_pos = 0; n_local_ref = 0; usr_field_pos = 0; n_usr_field = 0
            GOSUB fetchHeader

            CALL EB.READLIST('SSELECT ':file_name, rows, '', n_rows, '')
            FOR r_idx = 1 TO n_rows
                GOSUB fetchRow
            NEXT r_idx

            outp = CHANGE(header, @FM, fsep):@FM:rows
            GOSUB saveResults
        END
    END

    PRINT ret_msg

    STOP
*-----------------------------------------------------------------------------
parseArguments:

* File to be dumped (with company prefix)
    file_name = SENTENCE(1)
    IF NOT(file_name) THEN
        ret_msg = 'Usage: T24DMP FILE (SAMPLE_SIZE)'
    END

* Number of records to dump (all if not specified)
    sample_size = SENTENCE(2)
    IF NOT(sample_size) THEN
        sample_size = 'FULL'
    END

* TODO: Perhaps separators should be configurable as well
    fsep = CHARX(9); vsep = '[vm]'; ssep = '[sm]'

    RETURN
*-----------------------------------------------------------------------------
openFiles:

    file_p = ''; app_name = ''

* Validate the file name
    BEGIN CASE
    CASE file_name[1,2] EQ 'F.'
        app_name = file_name[3,LEN(file_name)]
    CASE file_name[1,5] MATCHES 'F3A.'
        app_name = file_name[6,LEN(file_name)]
    CASE OTHERWISE
        ret_msg = file_name:' is not a valid file name'
    END CASE

* Attempt to open the file to be dumped and related files
    IF NOT(ret_msg) THEN
        CALL CHECK.ROUTINE.EXIST(app_name, routine_exists, ret_info)
        IF routine_exists THEN
            OPEN file_name TO file_p THEN
                OPEN 'F.LOCAL.REF.TABLE' TO lrt_p ELSE STOP
                OPEN 'F.LOCAL.TABLE' TO lt_p ELSE STOP
                OPEN '&SAVEDLISTS&' TO sl_p ELSE STOP
            END ELSE
                ret_msg = 'File ':file_name:' does not exist'
            END
        END ELSE
            ret_msg = 'Application ':app_name:' does not exist'
        END
    END

    RETURN
*-----------------------------------------------------------------------------
fetchHeader:

* Field names and audit field multivalue prefixes from STANDARD.SELECTION
    CALL GET.STANDARD.SELECTION.DETS(app_name, r_ss)
    n_usr_field = DCOUNT(r_ss<SSL.USR.FIELD.NAME>,@VM)

* System field multivalue prefixes from application (F array)
    V$FUNCTION = 'XX'
    CALL @app_name

* Fetch system data and audit field names
    FOR i = 1 TO C$SYSDIM
        IF F(i) THEN
            IF F(i) NE 'XX.LOCAL.REF' THEN
                header<-1> = F(i)
            END ELSE
                local_ref_pos = i
             END
        END ELSE
            LOCATE i IN r_ss<SSL.SYS.FIELD.NO,1> SETTING pos THEN
                IF r_ss<SSL.SYS.SINGLE.MULT,pos> EQ 'M' THEN
                    header<-1> = 'XX-':r_ss<SSL.SYS.FIELD.NAME,pos>
                END ELSE
                    header<-1> = r_ss<SSL.SYS.FIELD.NAME,pos>
                END
            END ELSE
                usr_field_pos = i
                BREAK
            END
        END
    NEXT i

* Add local reference fields (STANDARD.SELECTION not reliable)
    READ r_lrt FROM lrt_p,app_name THEN
        n_local_ref = DCOUNT(r_lrt<EB.LRT.LOCAL.TABLE.NO>, @VM)
        FOR i = 1 TO n_local_ref
            READ r_lt FROM lt_p,r_lrt<EB.LRT.LOCAL.TABLE.NO,i> THEN
                header<-1> = r_lrt<EB.LRT.SUB.ASSOC.CODE,i>:'L_':r_lt<EB.LTA.SHORT.NAME>
            END
        NEXT i
    END

* Add user fields
    FOR i = 1 TO n_usr_field
        IF LEFT(r_ss<SSL.USR.FIELD.NO,i>,10) NE 'LOCAL.REF<' THEN
            header<-1> = r_ss<SSL.USR.TYPE,i>:'_':r_ss<SSL.USR.FIELD.NAME,i>
        END
    NEXT i

    RETURN
*-----------------------------------------------------------------------------
fetchRow:

    r_id = rows<r_idx>

* Fetch system fields
    READ r_app FROM file_p,r_id THEN
        row = r_id:@FM:r_app
    END

* Fetch local ref fields
	IF local_ref_pos THEN
		FOR i = 1 TO n_local_ref
			row<usr_field_pos+i-1> = r_app<local_ref_pos,i>
		NEXT i
		
		DEL row<local_ref_pos+1>
	END

* Fetch user fields (call IDESC)
    FOR i = 1 TO n_usr_field
        IF LEFT(r_ss<SSL.USR.FIELD.NO,i>,10) NE 'LOCAL.REF<' THEN
            row<usr_field_pos+n_local_ref+i-1> = 'IDESC'
        END
    NEXT i

    rows<r_idx> = CHANGE(CHANGE(CHANGE(row, @FM, fsep), @VM, vsep), @SM, ssep)

    RETURN
*-----------------------------------------------------------------------------
saveResults:

    outp_file = 'TAD_':file_name:'.txt'
    WRITE outp TO sl_p,outp_file
    ret_msg = file_name:' dumped into &SAVEDLISTS&/':outp_file

    RETURN
