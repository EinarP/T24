*-----------------------------------------------------------------------------
* <Rating>574</Rating>
*-----------------------------------------------------------------------------
    PROGRAM T24DMP
*-----------------------------------------------------------------------------
* Extracts T24 file contents with local and user fields
*-----------------------------------------------------------------------------
    $INSERT I_COMMON
    $INSERT I_EQUATE
    $INSERT I_F.STANDARD.SELECTION
    $INSERT I_F.LOCAL.REF.TABLE
    $INSERT I_F.LOCAL.TABLE

    ret_msg = ''

    GOSUB parseArguments
    IF NOT(ret_msg) THEN

        GOSUB openFiles
        IF NOT(ret_msg) THEN

            header = '@ID'
            local_ref_pos = 0; n_local_ref = 0; usr_field_pos = 0; n_usr_field = 0
            GOSUB fetchHeader

            rows = ''
            GOSUB selectRecords
            FOR r_idx = 1 TO n_rows
                GOSUB fetchRow
            NEXT r_idx

            result = CHANGE(header, @FM, fsep):@FM:rows
            GOSUB saveResult
        END
    END

    PRINT ret_msg

    STOP
*-----------------------------------------------------------------------------
parseArguments:

* File to be dumped (with company prefix)
    file_name = SENTENCE(1)
    IF NOT(file_name) THEN
        ret_msg = 'Usage: T24DMP FILE (SAMPLE_SIZE)'
    END

* Number of records to dump (all if not specified)
    sample_size = SENTENCE(2)

* TODO: Perhaps separators should be configurable as well
    fsep = CHARX(9); vsep = '{v}'; ssep = '{s}'

    RETURN
*-----------------------------------------------------------------------------
openFiles:

    file_p = ''; app_name = ''

* Validate the file name
    BEGIN CASE
    CASE file_name[1,2] EQ 'F.'
        company = 'BNK'
        app_name = file_name[3,LEN(file_name)]
    CASE file_name[1,5] MATCHES 'F3A.'
        company = file_name[2,3]
        app_name = file_name[6,LEN(file_name)]
    CASE OTHERWISE
        ret_msg = file_name:' is not a valid file name'
    END CASE

* Attempt to open the file to be dumped and related files
    IF NOT(ret_msg) THEN
        CALL CHECK.ROUTINE.EXIST(app_name, routine_exists, ret_info)
        IF routine_exists THEN
            OPEN file_name TO file_p THEN
                OPEN 'F.LOCAL.REF.TABLE' TO lrt_p ELSE STOP
                OPEN 'F.LOCAL.TABLE' TO lt_p ELSE STOP
                OPEN '&SAVEDLISTS&' TO sl_p ELSE STOP
                CALL LOAD.COMPANY(company)
            END ELSE
                ret_msg = 'File ':file_name:' does not exist'
            END
        END ELSE
            ret_msg = 'Application ':app_name:' does not exist'
        END
    END

    RETURN
*-----------------------------------------------------------------------------
selectRecords:

* TODO: Randomise sample (additionally?)

    CALL EB.READLIST('SSELECT ':file_name, rows, '', n_rows, '')
    IF sample_size AND sample_size LT n_rows THEN
        rows = rows[@FM,1,sample_size]
        n_rows = sample_size
    END

    RETURN
*-----------------------------------------------------------------------------
fetchHeader:

* Field names and audit field multivalue prefixes from STANDARD.SELECTION
    CALL GET.STANDARD.SELECTION.DETS(app_name, r_ss)
    n_usr_field = DCOUNT(r_ss<SSL.USR.FIELD.NAME>,@VM)

* System field multivalue prefixes from application (F array)
    V$FUNCTION = 'XX'
    CALL @app_name

    FOR f_idx = 1 TO C$SYSDIM
        BEGIN CASE

* Fetch system field names
        CASE F(f_idx) AND F(f_idx) NE 'XX.LOCAL.REF'
            header<-1> = F(f_idx)

* Fetch local reference field names (STANDARD.SELECTION not reliable)
        CASE F(f_idx) EQ 'XX.LOCAL.REF'
            local_ref_pos = f_idx
            READ r_lrt FROM lrt_p,app_name THEN
                n_local_ref = DCOUNT(r_lrt<EB.LRT.LOCAL.TABLE.NO>, @VM)
                FOR i = 1 TO n_local_ref
                    READ r_lt FROM lt_p,r_lrt<EB.LRT.LOCAL.TABLE.NO,i> THEN
                        header<-1> = r_lrt<EB.LRT.SUB.ASSOC.CODE,i>:'L_':r_lt<EB.LTA.SHORT.NAME>
                    END
                NEXT i
            END ELSE
                header<-1> = 'XX.LOCAL.REF'
            END

* Fetch audit field names
        CASE OTHERWISE
            LOCATE f_idx IN r_ss<SSL.SYS.FIELD.NO,1> SETTING pos THEN
                IF r_ss<SSL.SYS.SINGLE.MULT,pos> EQ 'M' THEN
                    header<-1> = 'XX-':r_ss<SSL.SYS.FIELD.NAME,pos>
                END ELSE
                    header<-1> = r_ss<SSL.SYS.FIELD.NAME,pos>
                END
            END ELSE
                usr_field_pos = f_idx
                BREAK
            END
        END CASE
    NEXT f_idx

* Add user field names
    FOR i = 1 TO n_usr_field
        IF LEFT(r_ss<SSL.USR.FIELD.NO,i>,10) NE 'LOCAL.REF<' THEN
            header<-1> = r_ss<SSL.USR.TYPE,i>:'_':r_ss<SSL.USR.FIELD.NAME,i>
        END
    NEXT i

    RETURN
*-----------------------------------------------------------------------------
fetchRow:

    r_id = rows<r_idx>

* Fetch system fields
    READ r_app FROM file_p,r_id THEN
        row = r_id:@FM:r_app
    END

* Fetch local ref fields (not all values might have been populated)
    IF local_ref_pos THEN
        local_ref_fields = ''
        FOR i = 1 TO n_local_ref
            local_ref_fields<i> = r_app<local_ref_pos,i>
        NEXT i
        row<local_ref_pos+1> = local_ref_fields
    END

* Fetch user fields
    usr_field_idx = 0
    FOR i = 1 TO n_usr_field
        IF LEFT(r_ss<SSL.USR.FIELD.NO,i>,10) NE 'LOCAL.REF<' THEN
            CALL IDESC(file_name, r_id, r_app, r_ss<SSL.USR.FIELD.NAME,i>, idesc_val)
            row<usr_field_pos+n_local_ref+usr_field_idx> = idesc_val
            usr_field_idx++
        END
    NEXT i

    rows<r_idx> = CHANGE(row, @FM, fsep)
*    rows<r_idx> = CHANGE(CHANGE(CHANGE(row, @FM, fsep), @VM, vsep), @SM, ssep)

    RETURN
*-----------------------------------------------------------------------------
saveResult:

    outp_file = 'TAD_':file_name:'.txt'
    WRITE result TO sl_p,outp_file
    ret_msg = file_name:' dumped into &SAVEDLISTS&/':outp_file:' (':n_rows:' records)'

    RETURN
