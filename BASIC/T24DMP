*-----------------------------------------------------------------------------
* <Rating>516</Rating>
*-----------------------------------------------------------------------------
    PROGRAM T24DMP
*-----------------------------------------------------------------------------
* Extracts T24 file contents with local and user fields
*-----------------------------------------------------------------------------
    $INSERT I_COMMON
    $INSERT I_EQUATE
    $INSERT I_F.STANDARD.SELECTION
    $INSERT I_F.LOCAL.REF.TABLE
    $INSERT I_F.LOCAL.TABLE

    ret_msg = ''

    file_name = SENTENCE(1); sample_size = SENTENCE(2); sample_type = ''
    GOSUB parseArguments
    IF ret_msg THEN GOSUB errorHandler

    file_p = ''; app_name = ''
    GOSUB openFiles
    IF ret_msg THEN GOSUB errorHandler

    header = '@ID'
    local_ref_pos = 0; n_local_ref = 0; usr_field_pos = 0; n_usr_field = 0
    GOSUB fetchHeader

    rows = ''
    GOSUB selectRecords
    FOR r_idx = 1 TO n_rows
        GOSUB fetchRow
    NEXT r_idx

    result = CHANGE(header, @FM, fsep):@FM:rows
    GOSUB saveResult

errorHandler:

    PRINT ret_msg

    STOP
*-----------------------------------------------------------------------------
parseArguments:

* File to be dumped (with company prefix) mandatory
    IF NOT(file_name) THEN
        ret_msg = 'Usage: T24DMP FILE ((H|T|R)SAMPLE_SIZE)'
    END

* Number of records to dump (all if not specified) and how
    IF sample_size AND NOT(sample_size*1) THEN
        sample_type = sample_size[1,1]
        IF sample_type MATCHES 'H':@VM:'T':@VM:'R' THEN
            sample_size = sample_size[2,LEN(sample_size)-1]
            IF NOT(sample_size*1) THEN
                ret_msg = 'Sample size must be numeric'
            END
        END ELSE
            ret_msg = 'Unknown sample type prefix'
        END
    END

* TODO: Perhaps separators should be configurable as well
    fsep = CHARX(9); vsep = '{v}'; ssep = '{s}'

    RETURN
*-----------------------------------------------------------------------------
openFiles:

* Validate the file name
    BEGIN CASE
    CASE file_name[1,2] EQ 'F.'
        company = 'BNK'
        app_name = file_name[3,LEN(file_name)]
    CASE file_name[1,5] MATCHES 'F3A.'
        company = file_name[2,3]
        app_name = file_name[6,LEN(file_name)]
    CASE OTHERWISE
        ret_msg = file_name:' is not a valid file name'
    END CASE

* Attempt to open the file to be dumped and related files
    IF NOT(ret_msg) THEN
        CALL CHECK.ROUTINE.EXIST(app_name, routine_exists, ret_info)
        IF routine_exists THEN
            OPEN file_name TO file_p THEN
                CALL LOAD.COMPANY(company)
            END ELSE
                ret_msg = 'File ':file_name:' does not exist'
            END
        END ELSE
            ret_msg = 'Application ':app_name:' does not exist'
        END
    END

    RETURN
*-----------------------------------------------------------------------------
selectRecords:

    CALL EB.READLIST('SSELECT ':file_name, rows, '', n_rows, '')

* Subset to tail, random, or head (default) records if requested
    IF sample_size AND sample_size LT n_rows THEN
        BEGIN CASE
        CASE sample_type EQ 'T'
            rows = rows[@FM,n_rows-sample_size,sample_size]

        CASE sample_type EQ 'R'
            random_rows = ''
            FOR i = 1 TO sample_size
                LOOP r_id = RND(n_rows) + 1 WHILE r_id MATCHES LOWER(random_rows) REPEAT
                random_rows<i> = rows<r_id>
            NEXT i
            rows = random_rows

        CASE OTHERWISE
            rows = rows[@FM,1,sample_size]
        END CASE

        n_rows = sample_size
    END

    RETURN
*-----------------------------------------------------------------------------
fetchHeader:

* System field names with multivalue prefixes from application (F array)
    V$FUNCTION = 'XX'
    CALL @app_name

* Audit and user field names with multivalue prefixes from STANDARD.SELECTION
    CALL GET.STANDARD.SELECTION.DETS(app_name, r_ss)
    n_usr_field = DCOUNT(r_ss<SSL.USR.FIELD.NAME>,@VM)

* Fetch system, local, and audit field names respectively
    FOR f_idx = 1 TO C$SYSDIM
        BEGIN CASE
        CASE F(f_idx) AND F(f_idx) NE 'XX.LOCAL.REF'
            header<-1> = F(f_idx)

        CASE F(f_idx) EQ 'XX.LOCAL.REF'
            OPEN 'F.LOCAL.REF.TABLE' TO lrt_p THEN
                READ r_lrt FROM lrt_p,app_name THEN
                    OPEN 'F.LOCAL.TABLE' TO lt_p THEN
                        n_local_ref = DCOUNT(r_lrt<EB.LRT.LOCAL.TABLE.NO>, @VM)
                        FOR i = 1 TO n_local_ref
                            READ r_lt FROM lt_p,r_lrt<EB.LRT.LOCAL.TABLE.NO,i> THEN
                                sac = r_lrt<EB.LRT.SUB.ASSOC.CODE,i>
                                header<-1> = sac:'L_':r_lt<EB.LTA.SHORT.NAME>
                            END
                        NEXT i
                    END
                END ELSE
                    header<-1> = 'XX.LOCAL.REF'
                END
            END
            local_ref_pos = f_idx

        CASE OTHERWISE
            LOCATE f_idx IN r_ss<SSL.SYS.FIELD.NO,1> SETTING pos THEN
                IF r_ss<SSL.SYS.SINGLE.MULT,pos> EQ 'M' THEN
                    header<-1> = 'XX-':r_ss<SSL.SYS.FIELD.NAME,pos>
                END ELSE
                    header<-1> = r_ss<SSL.SYS.FIELD.NAME,pos>
                END
            END ELSE
                usr_field_pos = f_idx
                BREAK
            END
        END CASE
    NEXT f_idx

* Add user field names
    FOR i = 1 TO n_usr_field
        IF LEFT(r_ss<SSL.USR.FIELD.NO,i>,10) NE 'LOCAL.REF<' THEN
            header<-1> = r_ss<SSL.USR.TYPE,i>:'_':r_ss<SSL.USR.FIELD.NAME,i>
        END
    NEXT i

    RETURN
*-----------------------------------------------------------------------------
fetchRow:

    r_id = rows<r_idx>

* Fetch system fields
    READ r_app FROM file_p,r_id THEN
        row = r_id:@FM:r_app
    END

* Fetch local ref fields (not all values might have been populated)
    IF local_ref_pos THEN
        local_ref_fields = ''
        FOR i = 1 TO n_local_ref
            local_ref_fields<i> = r_app<local_ref_pos,i>
        NEXT i
        row<local_ref_pos+1> = local_ref_fields
    END

* Fetch user fields
    usr_field_idx = 0
    FOR i = 1 TO n_usr_field
        IF LEFT(r_ss<SSL.USR.FIELD.NO,i>,10) NE 'LOCAL.REF<' THEN
            CALL IDESC(file_name, r_id, r_app, r_ss<SSL.USR.FIELD.NAME,i>, idesc_val)
            row<usr_field_pos+n_local_ref+usr_field_idx> = idesc_val
            usr_field_idx++
        END
    NEXT i

    rows<r_idx> = CHANGE(row, @FM, fsep)
*    rows<r_idx> = CHANGE(CHANGE(CHANGE(row, @FM, fsep), @VM, vsep), @SM, ssep)

    RETURN
*-----------------------------------------------------------------------------
saveResult:

    OPEN '&SAVEDLISTS&' TO sl_p THEN
        outp_file = 'TAD_':file_name:'.txt'
        WRITE result TO sl_p,outp_file
        ret_msg = file_name:' dumped into &SAVEDLISTS&/':outp_file:' (':n_rows:' records)'

    END ELSE
        ret_msg = 'Unable to output into &SAVEDLISTS&'
    END

    RETURN
